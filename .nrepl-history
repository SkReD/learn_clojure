(start-repl)
quit
(cell= (map vector (cycle ["#eee" "#fff"]) [1 2 3]))
(start-repl)
(cell= (map vector (cycle ["#eee" "#fff"]) [1 2 3]))
(start-repl)
 (cell= (get-in state [:croses) (partial swap! c assoc-in path))
game.logic/board
(game.logic/board)
(@game.logic/board)
`game.logic/board
game.logic/board
(start-repl)
(cell=)
(cell= ())
(cell= (constantly 1))
(hoplon.javelin/cell= (constantly 1))
(ns)
(game.logic/board)
(load game/logic.cljs)
(load src/game/logic.cljs)
(load game.logic)
(ns game.logic)
(board)
uit
quit
(start-repl)
@game.logic/board
(start-repl)
@game.logic/board
@game.logic/board2
@game.logic/board
(start-repl)
@game.logic/board
(swap! game.logic/board conj `(0 0 0))
(!swap game.logic/board assoc :0 `(1 2 3))
(!swap game.logic/board `(`(1 2 3)))
(!reset game.logic/board `(`(1 2 3)))
(!reset game.logic/board ((1 2 3)))
(!reset game.logic/board `(`(1 2 3)))
(get game.logic/board 0)
(game.logic/set-cross game.logic/board 0 0)
(game.logic/board)
(print game.logic/board)
(game.logic/set-cross game.logic/board 0 0)
(print game.logic/board)
(game.logic/set-cross game.logic/board 0 0)
(nth game.logic/board 0)
(nth (nth game.logic/board 0) 0)
(game.logic/set-cross game.logic/board 0 0)
(macroexpand-1 game.logic/set-cross)
(game.logic/set-cross game.logic/board 0 0)
(reset)
(game.logic/set-cross game.logic/board 0 0)
(reset! (nth (nth game.logic/board 0) 0) (mark-type signs))
(reset! (nth (nth game.logic/board 0) 0) (:cross signs))
(print game.logic/board)
(reset! (nth (nth game.logic/board 0) 0) (:cross game.logic/signs))
(print game.logic/board)
(print @game.logic/board)
(start-rep;)
(start-repl)
(print game.logic/board)
(game.logic/set-cross game.logic/board 0 0 )
(game.logic/set-cross game.logic/board 0 2 )
(game.logic/set-zero game.logic/board 0 2 )
(game.logic/get-mark game.logic/board 0 2 )
(deref game.logic/get-mark game.logic/board 0 2)
(deref (game.logic/get-mark game.logic/board 0 2))
(game.logic/set-zero game.logic/board 0 2 )
(game.logic/get-mark game.logic/board 0 2 )
(game.logic/set-zero game.logic/board 0 2 )
(game.logic/board)
(print game.logic/board)
(game.logic/board)
(print game.logic/board)
(swap! game.logic/board cons (0 0 0))
(swap! game.logic/board assoc :0 (0 0 0))
(swap! game.logic/board assoc 0 (0 0 0))
(print game.logic/board)
(swap! game.logic/board assoc 0 [0 0 0])
(swap! game.logic/board assoc 0 [0 0 1])
(swap! game.logic/board assoc 0 [0 0 3])
(swap! game.logic/board assoc 0 [0 0 2])
(swap! game.logic/board assoc 0 [0 0 1])
(swap! game.logic/board assoc 0 [0 0 3])
(read [1 2 3])
(eval `[1 2 3])
(eval [1 2 3])
(eval "[1 2 3]")
(eval (read-string "[1 2 3]"))
(read-string "(1 2 3)")
(read-string "(vec 1 2 3)")
(read-string)
(cljs.reader/read-string)
(cljs.reader/read-string "(1 2 3)")
(cljs.reader/read-string (print (1 2 3)))
(cljs.reader/read-string (print `(1 2 3)))
(cljs.write/write-string)
(cljs.writer/write-string)
(cljs.reader/read-string (str `(1 2 3)))
(swap! game.logic/board assoc 0 [0 0 1])
(swap! game.logic/board assoc 0 [0 0 2])
(start-repl)
(game.logic/set-cross 0 0)
(swap! board assoc-in [row-index column-index] (mark-type signs))
(ns-in game.logic)
(in-ns game.logic)
(in-ns `game.logic)
(swap! board assoc-in [0 0] (:cross signs))
(set-cross 0 0)
(board)
quit
(start-repl)
cljs/quit
quit
(start-repl)
(board)
quit
(start-repl)
/board)
cls/quit
cljs/
cljs/quit
quit
(start-repl)
(game.logic/board)
(print game.logic/board)
(map-indexed #({:index %1 }) [1 2 3])
(map-indexed (fn [i v]({:index %1 })) [1 2 3])
(map-indexed (fn[i v]{:index %1}) [1 2 3])
(map-indexed (fn[i v]{:index %}) [1 2 3])
(map-indexed #{:index %1} [1 2 3])
(map-indexed #{:index %0} [1 2 3])
(map-indexed #{:index %} [1 2 3])
(map-indexed #(identity {:index %}) [1 2 3])
(map-indexed #(identity {:index %1}) [1 2 3])
(map-indexed #(identity {:index %1 :value %2}) [1 2 3])
(swap! game.logic/board assoc-in [0 0 :value] 2)
(start-repl)
quit
(start-repl)
(ns server.store)
(board)
quit
(start-repl)
(identity active-mark)
(active-mark)
(ns game.logic)
(active-mark)
(@active-mark)
(print active-mark)
(print {:cross {:cross 2 :zeros 3}})
(print (:cross {:cross 2 :zeros 3}))
(ns game.logic)
(print active-mark)
quit
(start-repl)
(print active-mark)
(print @active-mark)
(print active-mark)
(ns game.logic)
(print active-mark)
(print @active-mark)
(ns game.logic)
(assoc-in board [row-index :value column-index :value] mark-type)
(assoc-in {:value [{:value [1]}]} [0 :value 0 :value] 2)
(ns server.store)
(board)
(start-repl)
(ns clojure.client)
(start-repl)
(ns boot.usr)
(ns boot.user)
(start-repl)
(ns server.store)
(board)
quit
(set-mark 1 1 2)
(require 'server.store :reload)
(set-mark 1 1 2)
(print board)
(print @board)
(require 'server.store :reload)
(set-mark 1 1 2)
(require 'server.store :reload)
(set-mark 1 1 2)
(require 'server.store :reload)
(set-mark 1 1 2)
(require 'server.store :reload)
(set-mark 1 1 2)
(require 'server.store :reload)
(set-mark 1 1 2)
(get-next-active-mark)
(require 'server.store :reload)
(set-mark 1 1 2)
(require 'server.store :reload)
(set-mark 1 1 2)
(require 'server.store :reload)
(set-mark 1 1 2)
(require 'server.store :reload)
(set-mark 1 1 2)
(require 'server.store :reload)
(set-mark 1 1 2)
(require 'server.store :reload)
(set-mark 1 1 2)
(require 'server.store :reload)
(set-mark 1 1 2)
(require 'server.store :reload)
(set-mark 1 1 2)
(require 'server.store :reload)
(set-mark 1 1 2)
(require 'server.store :reload)
(set-mark 1 1 2)
(require 'server.store :reload)
(set-mark 1 1 2)
(require 'server.store :reload)
(set-mark 1 1 2)
(require 'server.store :reload)
(set-mark 1 1 2)
quit
(start-repl)
(ns game.logic)
(print board)
(set-mark 1 1 2)
(get-empty-board)
(get-empty-board 3)
(diff/patch (get-empty-board 3) (set-mark 1 1 2))
(differ/patch (get-empty-board 3) (set-mark 1 1 2))
(require 'server.store :reload)
(differ/patch (get-empty-board 3) (set-mark 1 1 2))
(set-mark 1 1 2)
(require 'server.store :reload)
(print board)
(require 'server.store :reload)
(set-mark 1 1 2)
(print @board)
(require 'server.store :reload)
(set-mark 1 1 2)
(print @board)
(differ/patch (get-empty-board 3) (set-mark 1 1 2))
(print @board)
(differ/patch (get-empty-board 3) (set-mark 1 1 2))
(differ/patch (get-empty-board 2) (set-mark 1 1 2))
(differ/patch (get-empty-board 3) (set-mark 1 1 2))
(differ/patch (get-empty-board 1) (set-mark 1 1 2))
(set-mark 1 1 2)
(require 'server.store :reload)
(set-mark 1 1 2)
(differ/patch (get-empty-board 1) (set-mark 1 1 2))
(differ/patch (get-empty-board 2) (set-mark 1 1 2))
(differ/patch (get-empty-board 3) (set-mark 1 1 2))
(require 'server.store :reload)
quit
(recursive-diff-merge (set-mark 1 1 2) (get-empty-board 3))
quit
(set-mark 1 1 2)
(diff @board (assoc-in @board [1 :value 1 :value] 2)
(diff @board (assoc-in @board [1 :value 1 :value] 2))
(diff @board (assoc-in @board [1 :value 1 :value] 3))
(print @board)
(diff @board (assoc-in @board [1 :value 1 :value] 3))
(diff @board (assoc-in @board [2 :value 1 :value] 3))
(diff (get-empty-board 3) (assoc-in (get-empty-board 3) [1 :value 1 :value] 3))
(recursive-diff-merge (diff (get-empty-board 3) (assoc-in (get-empty-board 3) [1 :value 1 :value] 3)) (get-empty-board 3))
(require 'server.store :reload)
(recursive-diff-merge (diff (get-empty-board 3) (assoc-in (get-empty-board 3) [1 :value 1 :value] 3)) (get-empty-board 3))
(diff.utils/recursive-diff-merge)
quit
(diff.utils/recursive-diff-merge)
(recursive-diff-merge (diff (get-empty-board 3) (assoc-in (get-empty-board 3) [1 :value 1 :value] 3)) (get-empty-board 3))
(recursive-diff-merge (diff (get-empty-board 3) (assoc-in (get-empty-board 3) [1 :value 1 :value] 3) (get-empty-board 3))
(recursive-diff-merge (diff (get-empty-board 3) (assoc-in (get-empty-board 3) [1 :value 1 :value] 3)) (get-empty-board 3))
(recursive-diff-merge (diff (get-empty-board 3) (assoc-in (get-empty-board 3) [:index 1 :value :index 1 :value] 3)) (get-empty-board 3))
(recursive-diff-merge (diff (get-empty-board 3) (assoc-in (get-empty-board 3) [1 :value 1 :value] 3)) (get-empty-board 3))
(get-empty-board 3)
(assoc-in (get-empty-board 3) [1 :value 1 :value] 3)
(diff (get-empty-board 3) (assoc-in (get-empty-board 3) [1 :value 1 :value] 3))
(recursive-diff-merge (diff (get-empty-board 3) (assoc-in (get-empty-board 3) [1 :value 1 :value] 3)) (get-empty-board 3))
(defc temp nil)
(javelin.core/defc
(javelin.core/defc)
(require '[javelin.core :as j])
(j/defc)
(j/defc temp nil)
(require '[javelin.core :refer [cell] :refer-macros [defc cell=]])
(start-repl)
quit
(start-repl)
(all-ns)
(ns)
(board)
(ns game.logic)
(board)
(print board)
(reset! board 123)
(reset! board nil)
(reset! board 123)
(reset! board board)
(defc board nil)
("123" js/document.body.innerHTML)
(aset js/document "body" "innerHTML" "123")
(defc)
(cell)
(javelin.core)
(javelin.core/defc)
(javelin.core/defc ddd 123)
(require '[javelin.core])
(javelin.core/defc)
(javelin.core/defc ddd 123)
(print ddd)
(print @ddd)
(javelin.core/defc ddd nil)
(print @ddd)
(reset! ddd nil)
(print @ddd)
(print board-diff)
(sync-board)
quit
(start-repl)
(in-ns game.logic)
(ns game.logic)
(print board)
(reset! board nil)
(print board)
(cell= (reset! board (recursive-diff-merge board-diff board)))
(require '[javelin.core])
(javelin.core/cell= (reset! board (recursive-diff-merge board-diff board)))
(javelin.core/cell= (reset! board (diff.utils/recursive-diff-merge board-diff board)))
(pprint macroexpand (javelin.core/cell= (reset! board (diff.utils/recursive-diff-merge board-diff board)))))
(pprint macroexpand (javelin.core/cell= (reset! board (diff.utils/recursive-diff-merge board-diff board))))
(pprint (macroexpand (javelin.core/cell= (reset! board (diff.utils/recursive-diff-merge board-diff board)))))
(pprint (macroexpand '(javelin.core/cell= (reset! board (diff.utils/recursive-diff-merge board-diff board)))))
(pprint (macroexpand '(javelin.core/cell= (reset! board nil)))
(pprint (macroexpand '(javelin.core/cell= (reset! board nil))))
(pprint (macroexpand '(javelin.core/cell=))
(pprint (macroexpand '(javelin.core/cell=)))
(pprint (macroexpand '(javelin.core/cell= (reset! board nil)))
(pprint (macroexpand '(javelin.core/cell= (reset! board nil))))
(print (macroexpand '(javelin.core/cell= (reset! board nil))))
(clojure.core/pprint (macroexpand '(javelin.core/cell= (reset! board nil))))
(clojure.pprint/pprint (macroexpand '(javelin.core/cell= (reset! board nil))))
(print (macroexpand '(javelin.core/cell= (reset! board nil))))
(print board-diff)
(print board-actual)
(print board-src)
(start-repl)
